\input{res/slide_header.tex}

\title{Java}
\subtitle{Interface}
\author{FSR Informatik}
\date{\today}

\begin{document}

\begin{frame}
\titlepage
\end{frame}
\begin{frame}{Overview}
\tableofcontents
\end{frame}

\section{Additional Control Structures}
\subsection{Switch}
\begin{frame}[fragile]{Differentiate}
	\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
	public static void main (String[] args) {
	
	    int address = 2;
	    	
	    if (address == 1) {
	        System.out.println("Dear Sir,");	    
	    } else if (address == 2) {
	        System.out.println("Dear Madam,");		    
	    } else if (address == 4) {
	        System.out.println("Dear Friend,");		    
	    } else {
	        System.out.println("Dear Sir/Madam,");	
	    }
	}
	\end{lstlisting}
\end{frame}
\begin{frame}[fragile]{Differentiate with Switch}
	\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
	public static void main (String[] args) {
	
	    int address = 2;
	    
	    switch(address) {
	        case 1:
	            System.out.println("Dear Sir,");
	            break;
	        case 2:
	            System.out.println("Dear Madam,");
	            break;
	        case 4:
	            System.out.println("Dear Friend,");
	            break; 
	        default:
	            System.out.println("Dear Sir/Madam,");
	            break;
	    }
	}
	\end{lstlisting}
\end{frame}
\begin{frame}[fragile]{Differentiate with Switch}
	Depending on a \textcolor{red}{variable} you can switch the execution paths using the keyword \textbf{switch}.
	This works with \texttt{int}, \texttt{char} and \texttt{String}. \\
	\vfill
	The \textcolor{red}{variable} is compared 
	with the \textcolor{orange}{value} following the keyword \textbf{case}.
	% Strings are not compared - dot.equal
	If they are equal the program will enter the corresponding \textbf{case} \textcolor{gray}{block}.
	If nothing fits the program will enter the \textbf{default} block.
	\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
	public static void main (String[] args) {
	    switch(@\textcolor{red}{intVariable}@) {
	        case @\textcolor{orange}{1}@:
	            @\textcolor{gray}{doSomething();}@
	            @\textcolor{gray}{break;}@
	        default:
	            doOtherThings();
	            break;
	    }
	}
	\end{lstlisting}
\end{frame}
\begin{frame}[fragile]{Break}
	After the last command of the case block	you can tell the program to leave using \textbf{break}.\\
	Without \textbf{break} the program will continue regardless of
	whether a new case started, like in the example below.
	\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
	public static void main (String[] args) {
	
	    switch( 1 ) {
	        case 1:
	            System.out.println("enter case 1");
	        case 2:
	            System.out.println("enter case 2");
	            break;
	        default:
	            System.out.println("enter default case");
	            break;
	    }
	}
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Break - additional Information}
	The keyword \textbf{break} also stops the execution of loops.
	\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
	public static void main (String[] args) {
	
	    for (int i = 1; 1 < 10; i++) {
	        System.out.println("i = " + i);
	        if (i == 3) {
	            break;
	        }
	    }
	}
	\end{lstlisting}
	For more information visit:\\
	\scriptsize\url{http://docs.oracle.com/javase/tutorial/java/nutsandbolts/branch.html}
\end{frame}

%\subsection{Enum}
%\begin{frame}{}
%\end{frame}

\section{Visibility}
\subsection{Public and Private}
\begin{frame}{Public and Private}
	Until now we used \textbf{public} as standard visibility for methods and attributes. 
	The alternative is \textbf{private}.
	\vfill	
	A public attribute is accessable from all classes.
	\vfill
	A private attribute is only accessable from the own class.
	\vfill
	Visibility dictates Accessibility.
\end{frame}

\begin{frame}[fragile]{Example - public}
	\begin{lstlisting}
	public class Test {
	
	    public int number;
	}
	\end{lstlisting}
	\begin{lstlisting}
	public static void main (String[] args) {
	
	    Test test = new Test();
	    test.number = 16; // write
	    System.out.println(test.number); // read
	}
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Example - private}
	\begin{lstlisting}
	public class Test {
	
	    private int number;
	}
	\end{lstlisting}
	\begin{lstlisting}
	public static void main (String[] args) {
	
	    Test test = new Test();
	    // access to test.number is impossible
	}
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Example - private}
	A public/private method has access to a private attribute of the same class.
	\begin{lstlisting}
	public class Test {
	
	    private int number;
	    
	    public void changeNumber() {
	        this.number = 3; 
	        // access is possible
	    }
	}
	\end{lstlisting}
\end{frame}

\subsection{Getter und Setter}
\begin{frame}[fragile]{Access Attributes through Methods}
	Methods like \texttt{getAttributeX()} are called \textbf{getter}.
	\begin{lstlisting}
	public class Test {
	
	    private int number;
	    
	    public int getNumber() {
	        return this.number;
	    }
	}
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Modify Attributes through Methods}
	Methods like \texttt{setAttributeX(value)} are called \textbf{setter}.
	\begin{lstlisting}
	public class Test {
	
	    private int number;
	    
	    public void setNumber(int number) {
	        this.number = number;
	    }
	}
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Modify Attributes through Methods}
	A setter can check inputs and depending on the result modify attributes.
	\begin{lstlisting}
	public class Test {
	
	    // number is always greater than zero
	    private int number;
	    
	    public void setNumber(int number) {
	    	    if (number > 0) {
	            this.number = number;
	        }
	    }
	}
	\end{lstlisting}
\end{frame}

\subsection{Package}
\begin{frame}{Package}
	Packages help to organize large software with many classes.
	\vfill
	Every \textbf{package} comes with a corresponding \textbf{namespace}. 
	The package \emph{myPackage} creates the namespace \emph{myPackage}.
	%If you create a new folder \emph{myFolder} in your package \emph{myPackage}
	%you get a new namespace \texttt{myPackage.myFolder}.
	\vfill
	Inside a namespace you can not use the same name for two classes.
	But there can be a class \emph{Test} in namespace {myPackage} and 
	a class \emph{Test} in the namespace \emph{myOtherPackage}.
\end{frame}
\begin{frame}[fragile]{Eclipse - Creating a Package}
	\begin{enumerate}
		\item Right click at your project in the Package Explorer \hfill \\
			\menu[,]{New, Package}
		\item Name your package
		\item Press the \keys{Finish} button
	\end{enumerate}
\end{frame}
\begin{frame}[fragile]{Example 1}
	The package declaration is above the class declaration.
	\begin{lstlisting}
	package hello;	
	
	public class Number {
	
	    public int n1;
	    
	    public void setN1(int n1) {
	            this.n1 = n1;
	    }
	}
	\end{lstlisting}
\end{frame}
\begin{frame}[fragile]{Example 1 - Import}
	The class \emph{Number} from the package \emph{hello} will be imported.
	\begin{lstlisting}
	package notHello;
	
	import hello.Number;	
	
	public class Test {

	    public static void main (String[] args) {
	
	        Number number = new Number();
	        number.n1 = 16;
	    }
	}
	\end{lstlisting}
\end{frame}
\begin{frame}[fragile]{Protected}
	The attribute \emph{n1} has now the visibility \textbf{protected}. 
	This means \emph{n1} it is visible for everyone in the same namespace \emph{hello}.
	\begin{lstlisting}
	package hello;	
	
	public class Number {
	
	    protected int n1;
	    
	    public void setN1(int n1) {
	            this.n1 = n1;
	    }
	}
	\end{lstlisting}
\end{frame}
\begin{frame}[fragile]{Example 2}
	\emph{Number.n1} is protected, hence not visible for the class \emph{Test}.
	The access to \emph{n1} is possible through the public setter.
	\begin{lstlisting}
	package notHello;
	
	import hello.Number;	
	
	public class Test {

	    public static void main (String[] args) {
	
	        Number number = new Number();
	        number.setN1(16);
	    }
	}
	\end{lstlisting}
\end{frame}

%\subsection{Summary}
%\begin{frame}{Summary}
%	Method visibility works similar to Attribute visibility.
%	\begin{description}
%		\item[public]
%		\item[protected]
%		\item[private]
%	\end{description}
%	%TODO Why use visibility mechanisms
%\end{frame}

%\begin{frame}{Hiding}
%	
%\end{frame}

%TODO improve the whole section
\section{Static}
\subsection{Overview}
%TODO improve this overview - add an example - think about the headline
\begin{frame}{Static Keyword}
	An object is an instance of a class with its attributes and methods.
	The object is the actor and the class just a blueprint.
	\vfill
	Static class members are not linked to a certain instance of the class.
	Therefore the class can also be an actor.
	\vfill
	Static class members are:
	\begin{itemize}
		\item static attributes, often called class variables
		\item static methods, often called class methods
	\end{itemize}
\end{frame}

\subsection{Examples}
\begin{frame}[fragile]{Class Variables}
	In the setter \texttt{count} is addressed via \texttt{Example.count}.
	Using \texttt{this.count} is misleading, because \texttt{count} is a class variable.	
	\begin{lstlisting}
	public class Example {
	
	    public static count;

	    public setCount(int count) {
	        Example.count = count;
	    }
	}
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Class Variables - Test}
	The test prints the class variable \texttt{Example.count} which is altered
	by the different instances of the class \emph{Example}.	
	\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
	public class ExampleTest {
	
	    public static void main (String[] args) {
	        Example e1 = new Example();
	        Example e2 = new Example();
	        
	        e1.setCount(4);
	        System.out.println(Example.count); // prints: 4
	        e2.setCount(8);
	        System.out.println(Example.count); // prints: 8
	    }
	}
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Class Methods}
	Static methods can be called without an object.
	They can modify class variables but not attributes (object variables).
	\begin{lstlisting}
	public class Example {
	
	    public static count;

	    public static setCount(int count) {
	        Example.count = count;
	    }
	}
	\end{lstlisting}
	\begin{lstlisting}
	public static void main (String[] args) {
	        
	    Example.setCount(4);
	}
	\end{lstlisting}
\end{frame}

\subsection{Implications}
\begin{frame}[fragile]{Static is an One-Way}
	Methods from objects can:
	\begin{itemize}
		\item access attributes (object variables)
		\item access class variables
		\item call methods
		\item call static methods
	\end{itemize}
	Class methods can:
	\begin{itemize}
		\item access class variables
		\item call static methods
	\end{itemize}
\end{frame}

%\begin{frame}{When to use Static?}
%	The main method is static.
%\end{frame}

%\section{Abstract}
%\subsection{}
%\begin{frame}{}
%\end{frame}

%\begin{frame}{Singleton}
%\end{frame}

\section{Interface}
\subsection{Overview}
\begin{frame}{}
	An \textbf{interface} is a well defined set of constants and methods a class have to \textbf{implement}.
	\vfill
	You can access objects through their interfaces. So you can work with different kinds of objects easily.
	\vfill
	For Example: A post office offers to ship letters, postcards and packages. With an interface
	\emph{Trackable} you can collect the positions unified. 
	It is not important how a letter calculates its position.
	%TODO rethink the following sentence
	It is important that the letter communicate its position through the methods from the interface.
	%vfill
	%conclusion: Seperation from definition and implementation. 
	%The definition is ?denoted by? the interface.
\end{frame}
\subsection{Example}
\begin{frame}[fragile]{Interface Trackable}
	An interface contains method signatures. A signature is the definition of a method without the implementation.
	\begin{lstlisting}
	public interface Trackable {
	
	    public int getStatus(int identifier);
	    
	    public Position getPosition(int identifier);
	}
	\end{lstlisting}
	Note: The name of an interface often ends with the suffix \emph{-able}.
\end{frame}
\begin{frame}[fragile]{Letter implements Trackable}
	\begin{lstlisting}
	public class Letter implements Trackable {
	
	    public Position position;
	    private int identifier;
	
	    public int getStatus(int identifier) {
	        return this.identifier;
	    }
	    
	    public Position getPosition(int identifier) {
	        return this.position;
	    }
	}
	\end{lstlisting}
	The classes \emph{Postcard} and \emph{Package} also implement the interface \emph{Trackable}.
\end{frame}

\begin{frame}[fragile]{Access through an Interface}
	\begin{lstlisting}
	public static void main(String[] args) {
	
	    Trackable letter_1 = new Letter();
	    Trackable letter_2 = new Letter();
	    Trackable postcard_1 = new Postcard();
	    Trackable package_1 = new Package();
	    
	    letter_1.getPosition(2345);
	    postcard_1.getStatus(1234);
	}
	\end{lstlisting}
\end{frame}

\subsection{Multiple Interfaces}
\begin{frame}[fragile]{Two Interfaces}
	A class can implement multiple interfaces.
	\vfill
	\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
	public interface Buyable {
	
	    // constant
	    public float tax = 1.19f;
	
	    public float getPrice();
	}
	\end{lstlisting}
	\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
	public interface Trackable {
	
	    public int getStatus(int identifier);
	    
	    public Position getPosition(int identifier);
	}
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Postcard implements Buyable and Trackable}
	\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
	public class Postcard implements Buyable, Trackable {
	
	    public Position position;
	    private int identifier;
	    private float priceWithoutVAT;
	    
	    public float getPrice() {
	        return priceWithoutVAT * tax;
	    }
	
	    public int getStatus(int identifier) {
	        return this.identifier;
	    }
	    
	    public Position getPosition(int identifier) {
	        return this.position;
	    }
	}
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Access multiple Interfaces}
	\begin{lstlisting}
	public static void main(String[] args) {
	
	    Trackable postcard_T = new Postcard();
	    Postcard postcard_P = new Postcard();
	    Buyable postcard_B = new Postcard();

	    postcard_T.getStatus(1234);
	    postcard_B.getPrice();
	    postcard_P.getStatus(1234);
	    postcard_P.getPrice();
	}
	\end{lstlisting}
	\texttt{postcard\_P} can access both interfaces.\\
	\texttt{postcard\_T} can access Trackable.\\
	\texttt{postcard\_B} can access Buyable.
\end{frame}
%deault methods and static methods
\end{document}